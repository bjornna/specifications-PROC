= Definition Model

== Overview

This section describes the formal model of Work Plan and Task Plan, which is presented in UML form, as well as in TP-VML definition instance form. The following figure shows the main classes in the `proc.task_planning.definition` package.

[.text-center]
.proc.task_planning.definition model overview
image::{uml_diagrams_uri}/PROC-task_planning.definition-structure.svg[id=proc_definition_structure, align="center"]

The remaining classes are shown in various specialised views below.

== Plan Structure

The top-level structure for defining plans is a `WORK_PLAN`, which includes one or more related `TASK_PLANs` making up a logical goal-oriented plan. Within a Work Plan, two distinct lists of Task Plans are maintained: 

* `_plans_`: references all Task Plans; 
* `_top_level_plans_`: 'entry point' Task Plans that will be _active at Work Plan activation_ (often limited to only one). 

Non-top-level plans are those used as sub-plans within the hierarchy of a top-level Plan. A typical Work Plan / Task Plan structure is shown below in TP-VML form.

[.text-center]
.Work Plan top level structure
image::{diagrams_uri}/work_task_plans.svg[id=work_task_plans, align="center", width=50%]

A Work Plan has a number of global attributes, as follows:

* `_context_`: a data context for the Plan as a whole, which enables external variables (such as patient data items) to be tracked and updated;
* `_calendar_`: a global calendar containing entries that relate to this Work Plan, e.g. appointments, holidays etc;
* `_timeline_`: the global timeline for the Plan (and hence the subject) into which planned Tasks are fixed, with times specified as offsets from the zero point;
* `_event_wait_states_`: a reference list of all Event wait instances defined in the Plan;
* `_order_list_`: a table of references to orders being tracked in the Plan (described in <<_order_tracking>> below).

Both `WORK_PLAN` and `TASK_PLAN` are descendants of `CONTENT_ITEM`, which makes them a type of content that may occur in an openEHR `COMPOSITION`. Compositions used for this purpose have their `_category_` attribute set to the openEHR coded term `|Work Plan|`. This enables Work Plans to be committed to the openEHR EHR.

Plan internal structure is specified by the `_definition_` attribute of a `TASK_PLAN` is a `TASK_GROUP`, which has as its `_members_` any number of `PLAN_ITEMs`, which resolve either to more `TASK_GROUPs` (and some specialisations described below), or `TASK` entities.

=== The Plan Calendar

The Work Plan `_calendar_` consists of Plan-related entries fixed in time, as per the usual notion of a person's or organisational calendar. These will normally be a small subset of entries from a/the work management calendar of the organisation in whose IT system the Work Plans are used. A Plan calendar event can be used as the basis for a wait state (`TASK_WAIT._events_`) for Tasks in the Plan, either to indicate that something should be done on the date/time of the calendar event, or with a certain delay. Calendar events may include organisational events, national holidays and patient appointments. Wait states of the form '2 weeks after Easter Sunday' and '24 week ante-natal review (10 Feb 2019)' can therefore be defined in a Plan.

=== Plan Items

The `PLAN_ITEM` class is the parent of all fine-grained elements of a Task Plan. It has a mandatory `_description_` attribute, which represents a natural language specification of the work of the Task. 

`PLAN_ITEM` also has two optional attributes that control the timing behaviour of Task Plan elements: `_wait_spec_` and `_repeat_spec_`. The first enables a wait state (described above under <<_time_and_wait_states>>) to be applied to a Task or Group, which is triggered by time-related Events (clock time, reaching a point in a calendar) or other kinds of Events (external notifications etc). This allows the timing of a Task to be specified.

The second attribute, `_repeat_spec_`, enables a Task or Group to be marked as repeating. This is not primarily intended to replace the use of individual Task instances over time, such as repeated medication administrations, but rather to be used to indicate if larger sections (i.e. Task Groups) of planned Tasks are repeatable. Where repeats are specified, they will be unrolled into literal copies in the materialised expression of the Plan.

The optional `_period_` attribute defines the period of repetition. If not defined, each repetition commences according to the application of Task availability rules already defined on the individuals Tasks and/or Groups. If defined, the period should be greater than the duration of a single iteration. At execution time, a new iteration can only begin after completion of the previous one.

=== References to Clinical Quality Artefacts

The classes `WORK_PLAN` and `TASK_PLAN` may contain various references to externally defined clinical quality artefacts that they are based on or relate to, as follows:

* In `WORK_PLAN`:
** `_care_plan_`: a reference to an underpinning Care Plan from elsewhere in the EHR, if any exists;
** `_care_pathway_`: references to a care pathway from which this Task Plan was derived, if any;
* In `TASK_PLAN`:
** `_guideline_`: reference to a published guideline from which this particular Task Plan was derived, if any;
** `_best_practice_ref_`: reference to an institutional document that defines the best practice on which this Task Plan is based, if any;
** `_order_set_`: the identifier of an Order Set which this Task Plan uses, if any;
** `_workflow_id_`: an identifier shared among orders (`INSTRUCTIONs` and `ACTIONs`) from the Order Set instance used in this Task Plan, if any.

=== Class Definitions

include::{uml_export_dir}/classes/work_plan.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/plan_calendar.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/plan_timeline.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/calendar_entry.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_plan.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_participation.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/plan_item.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_repeat.adoc[leveloffset=+1]

== Task Plan Structure

The set of Tasks in a Task Plan is represented within a containment structure created using instances of the `TASK_GROUP` type, which has three key attributes. Execution of a Group is controlled by the `_execution_type_` and `_execution_rules_` attributes, which express sequential or parallel processing, and optionally other execution rules. It also has a `_training_level_` attribute which enables different visibility of Sub-Plans to users with different experience levels. This is described more fully below.

The Task Group construct enables two important ways to relate Tasks together:

* as a _module_ of work consisting of a series of Tasks, achieved by a Task Group with `_execution_type_ = sequential`;
* as a set of possible or mandatory _concurrent threads of work_, achieved by a Task Group with `_execution_type_ = parallel`.

A sequential Task Group corresponds to a single thread of processing at execution time, in which each of the Tasks becomes available to the worker (i.e. Task Plan's `_principal_performer_`) _in order_, and according to the specific conditions associated with each Task. The following illustrates a sequential Task Group.

[.text-center]
.Sequential Task Group
image::{diagrams_uri}/task_group_sequential.svg[id=task_group_sequential, align="center", width=45%]

=== Parallel Task Groups and Concurrency

The parallel Task Group represents a different degree of complexity, since it enables concurrent threads of work at execution time. In terms of YAWL and Petri net workflow theory, a parallel Task Group corresponds to paired _split_ and _join_ points. The following illustrates a parallel Task Group in TP-VML. The multi-point shape of the exit and entry elements is intended to convey multiple possible paths (the limitation of 3 points is purely visual, semantically, any number of paths is supported).

[.text-center]
.Parallel Task Group
image::{diagrams_uri}/task_group_parallel.svg[id=task_group_parallel, align="center", width=25%]

The type of split and join (i.e. AND, OR, XOR, or other) depends on additional rules for concurrent processing, represented by the attribute `_concurrency_mode_`, whose possible values define the type of split and join, as shown below. The concurrency mode is important because it tells the execution engine at runtime under what conditions to consider the group has completed. The AND cases is the simplest, since there is no conditional processing - all paths must be followed. The XOR case represents a 1/N choice, so completion is also trivial to determine. However the OR case is more complicated. It might initially seem as if the Group may be considered completed when the first path completes (i.e. 'quickest path wins'). However, an alternative reasonable approach is to wait for all paths that were commenced to complete. Both possibilities are catered for.

[cols="1,1,1,1,3", options="header"]
|===
|Concurrency mode    |TP-VML |Split/ +
                              join logic |Conditionality     |Semantics

|`and_all_paths`     
a|image::{diagrams_uri}/task_group_parallel_and.svg[id=task_group_parallel_and]
|AND                |(none)             |All parallel paths are followed.

|`xor_one_path`     
a|image::{diagrams_uri}/task_group_parallel_xor.svg[id=task_group_parallel_xor]
|XOR                |1/N                |Only one parallel path is followed.

|`or_first_completed`
a|image::{diagrams_uri}/task_group_parallel_or_first.svg[id=task_group_parallel_or_first]
|OR                 |N/M                |One or more paths may be commenced, and the Group is complete as soon as one path completes.

|`or_all_started`    
a|image::{diagrams_uri}/task_group_parallel_or_all.svg[id=task_group_parallel_or_all]
|OR                 |N/M                |One or more paths may be commenced, and the Group is complete when all paths commenced complete.

|===

The parallel / concurrent semantics attached to the Task Group do not indicate anything about conditional processing, i.e. conditions that might be used to choose outgoing paths from the split point represented by a Task Group in the XOR and OR logic cases. Consequently, the choice of path(s) to follow in the parallel case is determined _by the performer, not the system_. In order to specify conditions on paths, the `TASK_GROUP` the conditional subtypes <<_conditional_structures, described below>> are used.

=== Hierarachical Nesting

Task Groups of sequential and parallel types may be mixed in a hierarchical fashion. One structure is such that the overall work of a Task Plan is defined as a sequential Group in which some members are a parallel Group, as shown below.

[.text-center]
.Nested Task grouping - sequential structure
image::{diagrams_uri}/task_grouping.svg[id=task_grouping, align="center", width=75%]

Similarly, the outermost Group may be parallel, with the work being defined as sections of sequential work situated within a parallel Task Group, as shown below.

[.text-center]
.Nested Task grouping - parallel chains
image::{diagrams_uri}/task_grouping2.svg[id=task_grouping2, align="center", width=75%]

=== Generic Execution-time Semantics

The combination of the Task Group / Task hierachical pattern, which implicitly defines the graph structure of the 'normal flow' of a Task Plan, and the generic control attributes defined on `TASK` and its descendant types enable a significant amount of execution-time Plan processing to be implemented independently of any specific Task semantics.

=== Well-formedness

A significant consequence of the Task Group construct in the TP model is that each Task Group forms a sub-network within its container, where a _network_ is understood in the graph theory sense of a directed graph with a start `s` and terminal node `t`, containing paths from `s` to `t` n which all member elements are found. This holds for descendant types of `TASK_GROUP`, including the <<_conditional_structures, Conditional Structures>> described below. This is a more limited form of connectivity than allowed in YAWL or BPMN, which do not require matched split and join points.

=== Training Level

One challenge with creating Task Plan definitions is the level of detail to use, with respect to the variable level of skill of different performers. For a senior nurse, a briefer version of the Plan would be preferable with actions such as 'set up IV with catheter' being a single atom, whereas a trainee may need to see a more detailed set of sub-tasks. 

To enable a single Plan to be used in both ways, the concept of 'training level' is included in the model, on the `TASK_GROUP` class. This enables any Group of Tasks to be marked as having a specific training level, where a higher number corresponds to less experience. At execution time, the training level of the allocated performer can be obtained, and then used in comparison to the training level indicated on each Group (including the top-level Group of the whole Plan). If the user training level is higher, then the Group may be shown only as a single step (using its `_description_`, inherited from `PLAN_ITEM`); otherwise it may be shown as the set of sub-steps. This provides a simple way for the same Plan to be presented in different forms matching different performer experience levels.

The default value of `_training_level_` is 0.

=== Class Definitions

include::{uml_export_dir}/classes/task_group.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/execution_type.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/concurrency_mode.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/execution_rule.adoc[leveloffset=+1]

== General Task Semantics

Tasks are represented by the `TASK` class whose two concrete sub-types distinguish the two basic flavours of Task, namely _dispatchable_ and _performable_. `TASK` is a generic (i.e. templated) class, whose generic parameter is constrained to the type `TASK_ACTION`, the latter of whose subtypes defined the particular kinds of Tasks available. 

The `DISPATCHABLE_TASK<T>` class has two attributes to do with managing context change and callback. The `_wait_` flag indicates whether the current Task waits (i.e. blocks) while the dispatched work is performed, or whether it continues on asynchronously. The first constitutes a context switch, the second a context fork. The `_callback_` attribute attaches a special kind of Event wait state that is triggered on receipt of a callback. How callbacks function in detail is <<_callbacks,described below>>.

There are some key differences between the two kinds of Task as shown in the following table.

[cols="1,3,3", options="header"]
|===
|Task Type      |Description                                                                   |Lifecycle state

|_Performable_  |Task performed by the current performer.                                      |Advanced by actions of performer (real world actor)
|_Dispatchable_ |A Task whose work is dispatched for execution to another performer or system. |_wait_ = `True`: Advanced by receipt of callback notification +
                                                                                                _wait_ = `False`: Automatically advanced to `completed`
|===

=== Task Lifecycle

At runtime, it is the Tasks in a Plan that can be directly performed. Accordingly, it is the Task that has a lifecycle attached to it, containing states and transitions reflecting possible actions by the performer. 

[.tbd]
TBD: The lifecycle does not appear in the definition model `TASK` class as a data attribute since it is a runtime variable for a Task; hence it appears in the materialised model, <<Materialised Model,described below>>.

It is however useful to decribe the lifecycle here, since it represents a key part of Task semantics, and the occurrence of certain kinds of events influence whether a Task fails or completes, and potentially whether the Plan continues in execution.

The lifecycle only has to take account of the states a Task itself can pass through: states of an order (i.e. prescription, lab request) with which the Task may be associated will be visible in the documentation of the Task execution, i.e. separate openEHR `ACTION` or other Entry objects. The Task lifecycle states are as follows:

* `initial`: initial pseudo-state, not used in operation;
* `planned`: defined, but not yet available for execution;
* `available`: available for execution, due to previous Tasks having been performed, preconditions being met, and if there is a time specification on the Task, the current time being at or later than the stated time;
* `cancelled` (T): cancelled prior or during execution as not needed for success of the Plan;
* `completed` (T): performed to completion;
* `abandoned` (T): execution of current Task Plan was stopped before or after commencement due to completion being impossible;
* `underway`: indicates that a Task execution has been commenced;
* `suspended`: indicates that a Task execution has been suspended.

In the above, the terminal states are marked with '(T)'. The state machine is shown below.

[.text-center]
.Task lifecycle state machine
image::{uml_diagrams_uri}/PROC-TaskStateMachine.svg[id=task_state_machine, align="center", width=80%]

The state machine is designed to represent both stateless and stateful views of the actual execution state of a Task in the real world. The standard pathway is `available` => `completed` or `abandoned` or `cancelled`, which enables a user to indicate the outcome of executing a Task, without having to report interim states during execution in the real world. The pathways through the states `underway` and `suspended` are provided to represent in-execution states, which are needed for two cases:

* longer-running atomic Tasks;
* dispatchable Tasks that are blocked waiting on another performer.

==== Task Availability

Each Task in a new Plan execution starts in the `initial` state. Following the design principle <<Allocation,described earlier>>, the execution engine executing a Task Plan can determine the _availability_ i.e., when the transition `planned` => `available` may occur for any Task as follows:

* _control-flow_: preceding Tasks / Groups within the owning Task Group are in the `completed` or `cancelled` state;
* _wait state_: any Task or Group wait state has been exited due to the arrival of the relevant events (including time-related);
* _subject preconditions_: subject preconditions attached to the current Task Action are satisfied.

A Task is considered `available` according to this logic even if performer and/or resources have not been allocated.

The workflow application may provide an override capability so that a Task can be performed before it is determined to be available. This would enable a user to perform the Task anyway, causing the lifecycle transition `_override_` from `planned` to `available`. A corresponding `TASK_EVENT_RECORD` is created recording the use of the override.

=== Class Definitions

include::{uml_export_dir}/classes/task.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/dispatchable_task.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/performable_task.adoc[leveloffset=+1]

== Task Actions

The specific definition of the work of Tasks is provided by `TASK._action_`, of type `TASK_ACTION` and its subtypes. Two abstract sub-types `DISPATCHABLE_ACTION` and `PERFORMABLE_ACTION` distinguish the _dispatchable_ and _performable_ flavours of Task Action, corresponding to the two `TASK` subtypes. The following UML diagram shows `TASK_ACTION` and its subtypes in detail.

[.text-center]
.proc.task_planning.definition model - Task Actions
image::{uml_diagrams_uri}/PROC-task_planning.definition-actions.svg[id=rm_definition_actions, align="center"]

`TASK_ACTION` includes two attributes that apply to all subtypes. The first is `_subject_preconditions_`, which enables subject-related preconditions to be expressed, i.e. conditions referencing variables relating to the subject such as vital signs. These preconditions can be understood as conditions for safe processing, and should either be satisfied before proceeding, or else overridden by a competent performer who understands the implications.

A subject precondition is formally represented as a `BOOLEAN_CONTEXT_EXPRESSION`, whose `_expression_` value is a string in {openehr_expression_language}[openEHR Expression Language^] syntax.

Pre-conditions are evaluated at the point at which the Task to which they are attached becomes available during execution. If any pre-condition evaluates to False, the Task is in theory unable to be performed. A clinical professional may override at execution time, since it may always be the case that particular circumstances obviate the need for a particular pre-condition that normally applies.

The second generally applicable attribute is `_costing_data_`, since cost information may clearly be relevant to any Plan item. Costing is dealt with in detail below.

Performable Actions have two attributes. The `_other_participations_` and `_resources_` attributes allow other performers and passive resources to be defined for an Action. Both are subject to an allocation process at execution time, similar to that of the `_principal_performer_`. 

The subtypes of `TASK_ACTION` consist of the following:

[cols="1,1,5", options="header"]
|===
|Type   |TP-VML |Description

|`DEFINED_ACTION`
a|image::{diagrams_uri}/task-defined_task.svg[id=task_defined_task]
|An inline-defined Task to be performed by the principal performer of the Group (see below for details);

|`SUB_PLAN`
a|image::{diagrams_uri}/task-sub_plan.svg[id=task_sub_plan]
|A kind of Task that stands for another Task Plan (identified by the inherited `LINKED_PLAN._target_` attribute) to be performed by the current performer - usually a fine-grained set of steps designed to achieve the result of this Task.

|`SYSTEM_REQUEST`
a|image::{diagrams_uri}/task-system_request.svg[id=task_system_request]
|A kind of Task that consists of a request to a computational system, such as a data retrieval or procedure call, on behalf of the current performer;

|`HAND_OFF`
a|image::{diagrams_uri}/task-hand_off.svg[id=task_hand_off]
|A kind of Task that hands off to another Task Plan in the same Work Plan, having a different performer (identified via the `_target_` attribute inherited from `LINKED_PLAN`);

|`EXTERNAL_REQUEST`
a|image::{diagrams_uri}/task-external_request.svg[id=task_external_request]
|A Task type that consists of a request to an external organisational entity that is outside the current Work Plan and its execution environment, on behalf of the current performer;

|===

The following sections provide more detail on some of these model features.

=== Performable Actions

==== Sub-plans and Re-use

As described above, multiple Task Plans may be used to define a single logical plan of work. This occurs for two main reasons:

* _re-use_: Task Plans that can be used on their own, e.g. 'set up IV drip', are combined within a larger plan;
* _level of granularity_: a Task Plan can contain Tasks that can be represented as finer-grained Task Plans, which may potentially be used or passed over depending on the level of experience, known here as _training level_ of the performer.

The following instance diagram illustrates.

[.text-center]
.Task Plan linking
image::{diagrams_uri}/task_linking.svg[id=task_linking, align="center"]

This shows a Plan for dialysis with a single performer, 'dialysis nurse', and several sub-plans, each referred to by an instance of the `SUB_PLAN` class. Since a Sub-plan is a kind of Task, it has a _description_ and could be performed and signed off as if it were a normal inline `DEFINED_ACTION` by an experienced performer (training level high), or it might be entered into by a performer such as a trainee nurse. The `PLAN_ITME._training_level_` attribute can be used to set the experience level of sub-plans if required; implementing this behaviour at execution time would rely in the Plan execution engine using these settings.

==== Inline Defined Actions

Tasks whose definitions are stated within a Task Plan are modelled using the `DEFINED_ACTION` type. A detailed specification of the work to be done in a Defined Action  may be stated via optional atttribute `_prototype_` of type `ENTRY`, which enables the details of a Task to be specified in terms of a descendant of the `ENTRY` class. This is typically an `ACTION` instance but could be an `OBSERVATION`, `ADMIN_ENTRY` or other descendant. The following view of the UML illustrates.

[.text-center]
.proc.task_planning.definition - Definition Task
image::{uml_diagrams_uri}/PROC-task_planning.definition-defined_task.svg[id=proc_task_planning_definition_defined_task, align="center", width=50%]

The attribute is called 'prototype' because the target Entry instance is understood as a partially populated, prototype 'planning time' partial copy of an Entry that will be created when the Task is actually performed. For example, a Task Plan for administering medication at 8 hourly intervals over a number of days could consist of a number of `DEFINED_ACTIONs`, each having a protoype of an `ACTION` instance based on the `openEHR-EHR-ACTION.medication.v1` archetype or a templated version thereof. Each such instance would contain the structured description of the medication administration and time, and when the administration was actually performed, an `ACTION` instance would be created from the prototype, modified to reflect any divergence from the planned form of the Task, and committed to the EHR in the normal way.

The following illustrates Task definitions using prototypes.

[.text-center]
.Task definition
image::{diagrams_uri}/task_definition.svg[id=task_definition, align="center", width=55%]

Assuming that the Task Plan is archetyped in the same way as Entries and other elements of the EHR, this scheme supports various modes of design-time specification. The `_prototype_` attribute in a `TASK_PLAN` archetype will usually be represented by an archetype slot or external reference, which specifies identifiers of permitted archetypes (or templates) of the target type, i.e. `ACTION` or other Entry. This can be used in various ways, as follows:

* {openehr_am_adl2}#_external_references[external reference]: specifies a fixed archetype identifier which will be substituted in the templated form of the Task Plan. This has the effect of creating `ACTION` or other prototype instances in the `TASK_PLAN` structure;
* {openehr_am_adl2}#_archetype_slots[archetype slot]: specified using a slot constraint that is satisfied by one or more archetypes that may be specified by a template, or left open until runtime.

In the latter case, the slot may be filled in the Task Plan template with an `ACTION` or other Entry archetype, allowing the Tasks to be fully specified inline as in the external reference case. Alternatively, it may be left unresolved, which would allow the workflow application to choose the exact Task definition archetype at runtime.

One reason to allow a Task to contain a `_prototype_` reference that remains unresolved until runtime is if the Task represents the act of making an observation, for example, taking a blood pressure. In such cases, no prototype at all may be needed, and the Task `_description_` attribute (inherited from `PLAN_ITEM`) may be sufficient information for the performer. On the other hand, a prototype `OBSERVATION` could be specified in the `TASK_PLAN` template, which defines a particular form of the observation, e.g. a blood pressure which only records mean arterial pressure and cuff size.

To allow further flexibility, The multiplicity of the `_prototype_` attribute is unlimited, to allow for the possibility of one Task being prototyped by more than one Entry instance, e.g. an `ACTION` and an `OBSERVATION`, two `ADMIN_ENTRY` instances and so on.

=== Dispatchable Actions

The type `DISPATCHABLE_ACTION` is the abstract parent of various Action subtypes that represent work requested to be done by some other agent, i.e. external to the current Task Plan. The three sub-types correspond to 3 different types of other performer, i.e.:

* `HAND_OFF`: another principle performer in the same Work Plan;
* `EXTERNAL_REQUEST`: a performer outside the current Work Plan computational environment.
* `SYSTEM_REQUEST`: a computation to be performed by a system call;

The general execution scheme for such Actions is as follows:

* _dispatch_ the work request to a target actor or service;
* _block or continue_, according to the `_wait_` flag, which determines switch or fork behaviour; and
* process any _callback notification_, specified via the `_callback_` attribute.

The following sub-sections described the various subtypes of `DISPATCHABLE_ACTION`, while callbacks are described in detail further down.

==== Hand-offs and Coordinated Teamwork

Work Plans may be designed to contain multiple Task Plans, each corresponding to a team worker. In the execution of such a Work Plan, the performer of any Task Plan may at some point need to hand off to another performer, i.e. one of the other Task Plans in the same Work Plan. As described above, the original worker may wait or continue, and in both cases, receipt of a callback notification from the other Task Plan may cause a change in the execution path of the first Plan.

The following illustrates, using the example of an acute stroke management care process.

[.text-center]
.Task coordination
image::{diagrams_uri}/task_coordination.svg[id=task_coordination, align="center"]

In this Work Plan, three Task Plans are used to perform (parts of) the clinical work coordinated for managing an acute stroke, as per a Care Pathway. There are two Hand-offs, the first synchronous (`_wait_` = `True`; callback wait resumes at the next Task) and the second an asynchronous fork (`_wait_` = `False`).

==== External Request

The Task sub-type `EXTERNAL_REQUEST` represents a request by the current performer to an external entity completely outside of the current Work Plan computational context, to request some work on behalf of the performer. This is typically an organisation of which routine requests can be made (e.g. pathology laboratory). The request has to be defined generically, in terms of an organisation identifier, a request identifier (i.e. a name or type of job) and a list of other details, represented by the standard archetypable `ITEM_STRUCTURE`.

==== System Request

The Task sub-type `SYSTEM_REQUEST` represents a request to a _system_ with a computational interface on behalf of the performer, such as a logging facility or a decision support system. The request is defined in terms of a `SYSTEM_CALL` instance.

=== Class Definitions

include::{uml_export_dir}/classes/task_action.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/subject_precondition.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/performable_action.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/resource_participation.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/defined_action.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/sub_plan.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/dispatchable_action.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/hand_off.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/external_request.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/system_request.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/linked_plan.adoc[leveloffset=+1]

== Data-sets and Application Interaction

In order for performers to execute Task Groups and individual Tasks with a Plan, specific data must often be reviewed to enable the performer to know how to proceed. This is generally the case for Tasks that involve administering drugs to a patient, where the dose depends on one or more variables relating to the patient state, such as ECG data, INR, heart rate etc.

The following UML diagram shows the data-set related classes in detail.

[.text-center]
.proc.task_planning.definition model overview
image::{uml_diagrams_uri}/PROC-task_planning.definition-dataset.svg[id=proc_definition_dataset, align="center"]

A 'data-set' in openEHR is a template, normally displayed as a form within an application. Either a template or form identifier (or both) maybe be used to specify a data-set. A _review data-set_ may be specified on any Plan Item (i.e. Task Group of Task, of any kind) via the attribute `PLAN_ITEM._review_dataset_`, in order to signal to the runtime system to request the display of data at the start of that part of the Plan.

Related to this is the `_capture_dataset_` attribute of the `PERFORMABLE_TASK` type, which enables the association of a dataset or form for inputting data with a performable Task.

[.tbd]
TBD: describe how this relates to the data set(s) of `PERFORMABLE_ACTION._prototype_` .

=== Class Definitions

include::{uml_export_dir}/classes/dataset_spec.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/capture_dataset_spec.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/review_dataset_spec.adoc[leveloffset=+1]

== Conditional Structures

More advanced applications of Task Plans include four conditional structures, which may be considered as specific patterns based on the core classes. They are expressed in terms of descendants of `TASK_GROUP` and are illustrated in the following UML model. 

[.text-center]
.proc.task_planning package definition model (decision view)
image::{uml_diagrams_uri}/PROC-task_planning.definition-decision.svg[id=proc_task_planning_definition_decision, align="center"]

The `CHOICE_GROUP` class defines the essential semantics for all conditional structure types, which is that they conform to a parallel, XOR-logic (i.e. single choice) concurrency model, as indicated by the class invariants. In traditional workflow processing, any instance of a `CHOICE_GROUP` is thus an 'XOR gate'.

[.tbd]
TBD: we can theoretically relax the invariant to allow multiple paths to be chosen - this corresponds to conditional-OR processing in traditional workflow.

The specific sub-types are based on the design principles described earlier, which distinguished both different conditional structural types, and three different levels of system support, i.e. 'automated', 'decision support' and 'ad hoc'. The combination of structural types and levels of system/user interaction levels is realised in terms of variations on the `CHOICE_GROUP` and `CHOICE_BRANCH` classes shown above, which define a generic notion of a decision point from which multiple branches emanate. The variations in system support manifest as follows.

* _fully automated_: three kinds of fully defined decision structures, namely the `CONDITION_XX`, `DECISION_XX` and `EVENT_XX` classes shown in the UML diagram;
* _decision support_: where instances of the above structures should be considered recommendations only, the `_override_type_` attribute defined on `CHOICE_GROUP` may be used on any `XX_GROUP` to indicate that user override is allowed;
* _ad hoc_: a dedicated variation `ADHOC_GROUP` and `ADHOC_BRANCH` are used to represent multiple branches where no criteria are defined in the Plan definition, but instead provided by an execution-time user.

In the override and adhoc cases, a justification may be provided at execution-time for having overridden or made a particular adhoc choice. This is represented in the materialised model, and therefore does not appear in the definition model.

The three fully defined decision patterns are as follows.

The first is a structure in which a set of Task Groups are treated as separate branches from a common point in the Plan. Each branch is entered conditionally according to the Boolean expression included on the branch. The classes `CONDITION_GROUP` and `CONDITION_BRANCH` provide this structure, which is  equivalent to an if/then/else structure in a programming language. Semantically, the branches are evaluated in order, in the matter of an if/then/else structure, and the final member may be a catch-all branch that matches if nothing else does. Accordingly, the `_execution_type_` is constrained to `sequential`.

The following diagram shows a typical condition structure.

[.text-center]
.Condition structure
image::{diagrams_uri}/condition_structure.svg[id=condition_structure, align="center"]

The second pattern corresponds to a decision point in a workflow at which some expression is evaluated, and each outgoing branch corresponds to a sub-set of the expression's value range (`_value_constraint_` attribute). The classes `DECISION_GROUP` and `DECISION_BRANCH` provide this structure, which is  equivalent to a switch statement in a programming language. The branch sub-ranges should ideally be individually mutually exclusive, and collectively they should cover the entire value range of the expression. However, as with the Condition Group, the branches are processed in order stated in the definition (`_execution_type_` is constrained to `sequential`), which enables overlapping value constraints on the branches, and also a final catch-all 'else' branch, if needed. The latter would have an open value constraint of the correct type.

The following diagram shows a typical decision structure.

[.text-center]
.Decision structure
image::{diagrams_uri}/decision_structure.svg[id=decision_structure, align="center"]

The final structure is a wait state at which multiple branches correspond to the receipt of different events. Taken together, the events constitute a set of logical alternatives at the relevant point in the Plan. This structure is modelled using the classes `EVENT_GROUP` and `EVENT_BRANCH`, and is equivalent to a when / then / else  rules structure in a rule-based programming environment.

[.text-center]
.Event structure
image::{diagrams_uri}/event_structure.svg[id=event_structure, align="center"]

=== Class Definitions

include::{uml_export_dir}/classes/choice_group.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/override_type.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/choice_branch.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/condition_group.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/condition_branch.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/decision_group.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/decision_branch.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/blocking_group.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/blocking_branch.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/adhoc_group.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/adhoc_branch.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/event_group.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/event_branch.adoc[leveloffset=+1]

== Events

=== Event Types

Work plans inevitably interact with events in the external world, as well being driven by time. In this model, points in time are modelled in terms of Events that represent the _reaching_ of certain points in time or an entry in a calendar, as time passes. Consequently, specifying a time for a Task to be performed and waiting for certain Events before it can be performed are both specified in the latter form. The relevant part of the model, shown below, consists of various types of Events, and additionally, various types of _wait states_ that may be used to intercept them.

[.text-center]
.proc.task_planning model - Events
image::{uml_diagrams_uri}/PROC-task_planning.definition-event.svg[id=proc_task_planning_definition_event, align="center"]

The various Event types are shown below, with their TP-VML representations.

[cols="1,<2,4", options="header"]
|===
|Type   |TP-VML |Description

|`TIMER_EVENT`
a|image::{diagrams_uri}/event_timer.svg[id=event_timer]
|Event generated by the expiry of a Timer that was launched at some earlier time.

|`TIMELINE_MOMENT`
a|image::{diagrams_uri}/event_timeline_moment.svg[id=event_timeline_moment]
|Event generated by system clock reaching a fixed time-point on the Work Plan timeline, specified by an offset from the Work Plan '0-point' plus an optional fixed time in the day. The latter enables fixed points in time such as a particular hour of day or customary time such as 'afternoon' to be specified. A combination of the two such as `P2D`, `13:30:00` can thus be used to state a time like '13:30 on day 2 of the plan'.

|`CALENDAR_EVENT`
a|image::{diagrams_uri}/event_calendar_event.svg[id=event_calendar_event]
|Event generated by system clock reaching an event in the global Plan calendar, which is specified in absolute time, independent of the Work Plan timeline.

|`TASK_TRANSITION`
a|image::{diagrams_uri}/event_task_transition.svg[id=event_task_transition]
|Event generated by the lifecycle transition of a Task, such as transition to `cancelled` or `done`.

|`STATE_TRIGGER`
a|image::{diagrams_uri}/event_state_trigger.svg[id=event_state_trigger]
|An event generated by a change in a tracked variable, or a Boolean expression based on tracked variables, e.g. a value reaching a threshold.

|`MANUAL_NOTIFICATION`
a|image::{diagrams_uri}/event_manual_notification.svg[id=event_manual_notification]
|An event that is manually notified to the Plan execution engine by a user.

|`SYSTEM_NOTIFICATION`
a|image::{diagrams_uri}/event_system_notification.svg[id=event_system_notification]
|An event that is notified to the Plan execution engine by a system.

|`DELAY_EVENT`
a|image::{diagrams_uri}/event_delay.svg[id=event_delay]
|A special kind of event is used to represent any other event with an added delay.

|`CALLBACK_NOTIFICATION`
a|image::{diagrams_uri}/event_callback.svg[id=event_callback]
|A callback notification connected to a dispatch for a Dispatchable Task (Hand-off, External Request, System Request).

|===

Instances of all of these types on their own only identify the type and source of an event - a wait state is required to catch an event. There are three types of wait state used in a TP definition: Task Wait, Timer Wait and Callback Wait. These are described below.

=== General Facilities

==== Timers

A generic timer can be specified using the Event type `TIMER_EVENT`. This is either attached to a `TASK_WAIT` wait state, which controls when a Task becomes available, or to a `TIMER_WAIT` wait state, which is used to represent a timeout on another wait state. `TIMER_WAIT` is based on the generic type `EVENT_WAIT<TIMER_EVENT>` and provides a way to specify a Timer (the `TIMER_EVENT` instance) and listen for it (the `TIMER_WAIT` instance).  A `TIMER_WAIT` creates a separate Event wait state that listens for a Timer event launched some duration after activation, and may result in specific actions, specified via the inherited `EVENT_WAIT._success_action_` attribute.

The timer represented by a `TIMER_EVENT` is started when the wait state to which it is attached is reached in the execution.

==== Event Wait State

The class `EVENT_WAIT<T>` defines a generic model of a general-purpose event wait state that may be specialised for particular purposes. Its attributes are as follows:

* `_success_action_` of type `EVENT_ACTION`, which defines possible actions to occur on receipt of an event;
* `_timeout_` of type `TIMER_WAIT`, whose `_success_action_` defines possible actions when no event is received.

The `EVENT_ACTION` type defines a number of things the system can do on a triggering event:

* make a system call, if the `_system_call_` attribute is set, e.g. to cause a notification to be sent or write to a system logger;
* displaying a message to the user, specified in the `_message_` attribute;
* optionally indicate a specific lifecycle state for the Plan Item (a Task or Task Group) receiving the event, specified by `_receiver_thread_next_state_`;
* optionally indicate where execution should resume in the plan, for example at an earlier Task, via the `_resume_action_` attribute, whose value is an instance of `RESUME_ACTION`, defining the `_resume_type_` and `_resume_location_` attributes.
    
=== Task Wait State

The principal way to wait for events is via the `TASK_WAIT` attachable to any `PLAN_ITEM` via the `_wait_spec_` attribute. The `TASK_WAIT` class represents a wait state that defines when a Task should enter the `available` state from the `planned` state in terms of Events of the types described above. Its `_events_` attribute enables multiple Events to be used as triggers, with an assumed logical OR relation among them. This enables the specification of triggers such as 'at 8pm on day 1, OR when oxygen saturation drops below 90% (whichever comes first)'. The optional `_event_relation_` attribute allows the Task to be specified as commencing `before`, `with` or `after` the trigger event (such as a meal). 

The following figure illustrates typical uses of `TASK_WAIT`.

[.text-center]
.Task wait state 
image::{diagrams_uri}/task_wait_state.svg[id=task_wait_state, align="center"]

==== Time-out

A timeout can be set on a Task Wait state by setting `TASK_WAIT._timeout_` with a `TIMER_WAIT` instance, which is activated when the Task Wait state is reached in the execution. This is useful in cases where Event receipt is not certain. The `TIMER_WAIT` generates a timer event if no other event is received; conversely, receipt of any other event cancels the timeout timer. The `TIMER_EVENT` attached to `TIMER_WAIT._event_` indicates the duration of the timer. The `_success_action_` of the `TIMER_WAIT` indicates actions to execute if the timer fires. The following Plan fragment illustrates.

[.text-center]
.Timing patterns
image::{diagrams_uri}/uc_task_timing_1.svg[id=timing_patterns_1, align="center"]

A Timeout can be also be used on a callback, via `CALLBACK_WAIT._timeout_`.

==== Reminder

When an event specified by a Task Wait state fires, it puts the Task into the `available` lifecycle state. In typical real world situations, the performer may not realise, or may be busy on something else. To enable the performer to be notified, and / or to indicate what delay before commencement is regarded as acceptable, the `TASK_WAIT._start_window_` attribute may be used to specify a `REMINDER` notification, which specifies a duration from the moment of first becoming available, optionally with a notification, specified via the inherited `_success_action_` attribute. If `REMINDER._repeats_` is non-zero, more than one reminder event may be generated. An example is illustrated below.

[.text-center]
.Task wait state with reminder
image::{diagrams_uri}/task_wait_state_reminder.svg[id=task_wait_state_reminder, align="center"]

The execution processing associated with a Reminder is that one or more Reminder events is generated by the system for a Task which is already `available`. Each of Reminder event will normally cause a communication to the principle performer via the message defined in its `_success_action_`. The performer responds by performing the work of the Task, and progressing it to a final state, in the normal way (possibly via the `underway` state, for a long-running Task). As soon as the Task is progressed beyond the `available` state, no further Reminders occur.

==== Lifecycle Transition Override

In some cases, it may be necessary to progress a Task to a state other than `available`. This may be achieved by specifying `TASK_WAIT._next_state_`.

=== Callbacks

A callback is the mechanism to state what happens when control returns to a Dispatchable Task (such as a Hand-off or External Request) from its target. It is defined in the model by `CALLBACK_WAIT`, a specialisation of `EVENT_WAIT<CALLBACK_NOTIFICATION>`, which represents a wait state to receive notifications of Dispatch completion, as well as timeout if no response is received. The callback event is formally represented by the `CALLBACK_NOTIFICATION` class. These classes are shown in the following view of the UML model.

[.text-center]
.Callback Wait
image::{uml_diagrams_uri}/PROC-task_planning.definition-callback_wait.svg[id=proc_definition_callback_wait, align="center"]

In order to define the processing on receipt of a callback event, `CALLBACK_WAIT` adds two attributes to `EVENT_WAIT<T>`:

* `_fail_action_`: enables a different `EVENT_ACTION` to be specified on receipt of a callback with a 'fail' status;
* `_custom_actions_`: enables a custom set of `EVENT_ACTIONs` to be specified, in the form of a Hash table, with a specific Event Action for each key; the keys are assumed to represent specific return statuses of the remote Task.

A Callback Wait thus has three standard Event responders: `_success_action_`, `_fail_action_` and `_timeout_`, and additionally any number of customer responders (`_custom_actions_`). 

A callback at execution time is achieved either internally in the TP system, or externally in the real world (e.g. by the subject returning to a clinic reception), which requires it to be manually signalled to the TP engine. The notification route is indicated by the attribute `CALLBACK_NOTIFICATION._manually_notified_`. In both cases, the `CALLBACK_NOTIFICATION` event carries the details of the event to be matched. In the manual notification, matching of `_subject_id_` etc will be carried out manually, e.g. by staff identifying the patient.

Task lifecycle state processing occurs both at the point of dispatch and return and/or timeout; the details are dependent on whether `DISPATCHABLE_TASK._wait_` is set or not, on what the response event type was (_success_, _fail_, some custom event), and whether `EVENT_ACTION._receiver_thread_next_state_` is set for any event. The latter setting can be used to override the default lifecycle state processing.

The following table shows the TP-VML representation and processing of the various permutations of `DISPATCHABLE_TASK._wait_`  and `_callback_`.

[cols="1,3,2,2,1", options="header"]
|===
|Dispatchable +
 Task           |TP-VML     |Dispatch +
                             processing     |Default +
                                             Response + 
                                             processing     |Timeout handling

|wait +
 + no callback +
 (context switch)
a|image::{diagrams_uri}/dispatchable_wait_no_callback.svg[id=dispatchable_wait_no_callback]
|Wait; +
 -> `underway` state
|-> `completed` state
|plan default

|wait +
 + callback +
 (context switch)
a|image::{diagrams_uri}/dispatchable_wait_callback.svg[id=dispatchable_wait_callback]
|Wait; +
 -> `underway` state
|process callback^*^: +
 _success_: +
 -> `completed` state +
 _fail_: +
 -> `abandoned` state +
 _timeout_: +
 -> `abandoned` state +
  +
 + Custom actions
 + process Event actions
|Use `_callback.timeout_` if set

|don't wait +
 + no callback +
 (context fork)
a|image::{diagrams_uri}/dispatchable_no_wait_no_callback.svg[id=dispatchable_no_wait_no_callback]
|-> `completed` state
|
|plan default

|don't wait +
 + callback +
 (context fork)
a|image::{diagrams_uri}/dispatchable_no_wait_callback.svg[id=dispatchable_no_wait_callback]
|-> `completed` state
|process callback^*^: +
 Event actions
|Use `_callback.timeout_` if set

5+|^*^default state processing; may be overridden using `EVENT_ACTION._receiver_thread_next_state_`, for example to set the next state for the `fail` and `timeout` notifications to `cancelled` rather than `abandoned` (i.e. stop the current Task, but don't abandon the plan).

|===

If the attached `CALLBACK_WAIT` object includes `EVENT_ACTIONs` that have `_system_call_` or `_message_` set for any of the notifications, these are processed in the normal way. If there is no `CALLBACK_WAIT` attached, no other callback processing is performed, and the timeout timer is determined by the global default timer for this dispatch.

It would be reasonable to design an implementation with a default message of the form `"Task $task_name[id=$task_id] completed with $state"`, and a global flag `_default_messages_on_` to obviate the need to always set basic messages in `EVENT_ACTION`.

In the case of a context fork, the source Task has performed its work as soon as the dispatch has occurred, and its state is set to `done`. The next Task(s) become `available` in the normal way, and processing continues. At some later point in time, a status notification of timeout may be received from the remote Task. This will be processed similarly to the above, with the exception that the next state processing, _if explicit next states are set_, is  _with respect to the enclosing Task Group_, which may be the top-level Group of the Task Plan. This allows the possibility of the callback processing to cause the local execution pathway to stop with abandonment, or cancellation. The default next-state processing is 'no change', i.e. the current execution path doesn't care what happens to the remote thread. However, if `EVENT_ACTION._receiver_thread_next_state_` is set for an execution status of the remote Task, the execution of the Task Group containing the source Task may be ended (`cancel`) or the whole Plan abandoned (`abandon`). Such a transition might even be set on `success`, which provides a way to model 'first one wins' logic.

The following diagram shows the definition structure for a dispatchable Task with a standard callback.

[.text-center]
.Standard callback example
image::{diagrams_uri}/uc_task_callback_1.svg[id=timing_callback_pattern_1, align="center"]

The following diagram illustrates a custom callback.

[.text-center]
.Custom callback example
image::{diagrams_uri}/uc_task_callback_2.svg[id=timing_callback_pattern_2, align="center"]

==== Callback with Custom Resume Behaviour

The attribute `EVENT_ACTION._resume_action_` of type `RESUME_ACTION`, and its attribute `_resume_location_` enable custom post-callback behaviour to be stated. The default is to process the `EVENT_ACTION` (e.g. post a message, make a system call etc), and then to complete the current Task and progress to the next in the normal way. A custom resume action alows a different resumption location to be specified, as defined by the enumeration `RESUME_TYPE`. This kind of resumption is described below in the section on <<_resume_semantics>>.

=== Class Definitions

include::{uml_export_dir}/classes/task_wait.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/plan_event.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/delay_event.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/manual_notification.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/system_notification.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/callback_notification.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/state_trigger.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/timer_event.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/calendar_event.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/timeline_moment.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_transition.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/event_wait.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/timer_wait.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/reminder.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/callback_wait.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/event_action.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/resume_action.adoc[leveloffset=+1]

== Order Tracking

A small number of features in the model are designed to support the tracking of orders from a Work Plan. The following UML view shows the relevant classes and properties. 
[.text-center]
.Order tracking
image::{uml_diagrams_uri}/PROC-task_planning.definition-order_tracking.svg[id=proc_definition_order_tracking, align="center"]

The facilities consist of the following:

* the `ORDER_REF` class, representing an 'order reference', keyed by the `_order_tag_` attribute;
* `WORK_PLAN._order_list_` is a table of Order Refs being tracked by the current Plan;
* `TASK._order_tags_` allows any Task to reference one or more `ORDER_REF` instances in the Work Plan `_order_list_`.

These features enable the creation and/or tracking of orders in an EHR system, according to various scenarios described below. Orders as described here are usually represented as openEHR Instructions and Actions committed to an openEHR EHR (within Compositions), but may in fact be any object(s) that can be referred to by a `LOCTABLE_REF`, which contains a URI. The following sub-sections assume openEHR Instructions and Actions for simplicity of explanation.

A key property in all scenarios is `_order_tag_`, used to _identify_ an order tracking reference (i.e. an `ORDER_REF`), and `TASK._order_tags_` to refer to one or more such references from any Task in the Plan. An order tag may take any String value not containing white space characters. The recommended approach is to use strings meaningful and unique within the Plan context, such that every order is distinguished, including distinct instances. For example, the value `"hypertension_medication"` may be sufficient within one Plan to identify and track an order for such medication, but if the Plan potentially may track two or more such medications, more unique values will be required, e.g. `"beta_blocker_medication"`, `"ACE_inhibitor_medication"` etc. Similarly, orders for different types of insulin (typical for diabetics) would need to be distinguished.

Multiple order tags may be used in a `TASK` for the case where a single Task causes creation of multiple orders, or a single Task waits on events (Action commits) from multiple orders.

For Plans in which repetition occurs (`PLAN_ITEM._repeat_spec_`), order tags may be constructed using the format `"xxxx@n"`, e.g. `"doxorubicin@1"`, `"doxorubicin_admin@2"` to refer to the orders for Doxorubicin in two distinct cycles of chemtherapy mentioned in the same Work Plan.

=== Tracking an Existing Order

In this scenario, at Work Plan design time, an order _already exists_ in the form of an Instruction committed to a patient EHR. This might be a standing order, e.g. for insulin for a diabetic, or any other long-running medication or therapy for a sufferer of a chronic illness. The Plan might be used to track patient or healthcare professional administrations of such a medication.

Since it is possible to construct a `LOCATABLE_REF` to the `INSTRUCTION` (and indeed, to a contained `ACTIVITY`), it may be referenced from a Work Plan using an `ORDER_REF` instance, via the `_order_ref_` property. The corresponding Instruction archetype identifier may also be recorded, enabling direct lookup by the TP engine, for use within the Plan modelling environment. The `_order_tag_` field will be set to a value that refers to the order in a sufficiently precise way as to be unique within the Work Plan.

This scheme allows Tasks to be defined within the Plan that have a Task Wait (`PLAN_ITEM._wait_spec_`) that wait on an event (e.g. `SYSTEM_NOTIFICATION` or `MANUAL_NOTIFICATION`) that is generated due to subsequent commits to the EHR of `ACTIONs` for the original order (e.g. drug administration events, cancellation or suspension of medication by the doctor etc).

=== Creating and Tracking an Order

In this scenario, the Work Plan is the creator of the order(s) of interest. At Work Plan _design time_, there is no order (i.e. `INSTRUCTION`) in the EHR (this will only occur at Plan execution time), so  `ORDER_REF._order_ref_` cannot initially be populated. An `ORDER_REF` can nevertheless be created for the order at Plan design time, with the `_order_tag_` being used to refer to the order from within the Work Plan. A typical Plan structure in this case might contain the following, for each order:

* a `PERFORMABLE_TASK<DEFINED_ACTION>` with associated `_capture_dataset_`, representing the entry of routine data and creation of the order, resulting in a commit to the EHR system of a Composition containing an Instruction for the order;
* a subsequent `DISPATCHABLE_TASK<SYSTEM_REQUEST>` (or `DISPATCHABLE_TASK<EXTERNAL_REQUEST>`) that causes the appropriate API call or message to be generated and sent to the filler of the order (e.g. pharmacy, laboratory etc); this Task may include a callback wait state (`DISPATCHABLE_TASK._callback_`) so that it blocks and waits for a result within a certain time-frame.

Both the Performable and Dispatchable Tasks would use `TASK._order_tags_` to logically refer to the same order. (Note that any number of pairs of Performable and Dispatchable Tasks may be defined to create and react to different orders being processed within the same Work Plan).

The concrete callback event can be arranged to occur when an `ACTION` for the order of interest is committed to the EHR. This relies on the population of the relevant Work Plan `CONTEXT_REF._order_ref_` attribute within the TP engine execution environment, at the moment the order is created in the EHR system. This then allows commits of `ACTIONs` for that order (among others, generally) to be matched with the Dispatchable Task(s) waiting on them.

The Dispatchable Task might be located in a repeating section of the Plan, if the intention is to await multiple Actions for the same Instruction.

An example of a Work Plan representing this scenario is available in the {openehr_tp_examples}#_order_coordination[Task Planning Examples^] document.

=== Class Definitions

include::{uml_export_dir}/classes/order_ref.adoc[leveloffset=+1]

== Cost Tracking

[.tbd]
TBD: describe cost tracking.

=== Class Definitions

include::{uml_export_dir}/classes/task_costing.adoc[leveloffset=+1]
