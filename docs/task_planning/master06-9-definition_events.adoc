== Events

=== Event Types

Work plans inevitably interact with events in the external world, as well being driven by time. In this model, points in time are modelled in terms of Events that represent the _reaching_ of certain points in time or an entry in a calendar, as time passes. Consequently, specifying a time for a Task to be performed and waiting for certain Events before it can be performed are both specified in the latter form. The relevant part of the model, shown below, consists of various types of Events, and additionally, various types of _wait states_ that may be used to intercept them.

[.text-center]
.proc.task_planning model - Events
image::{uml_diagrams_uri}/PROC-task_planning.definition-event.svg[id=proc_task_planning_definition_event, align="center"]

The various Event types are shown below, with their TP-VML representations.

[cols="1,<2,4", options="header"]
|===
|Type   |TP-VML |Description

|`TIMER_EVENT`
a|image::{diagrams_uri}/event_timer.svg[id=event_timer]
|Event generated by the expiry of a Timer that was launched at some earlier time.

|`TIMELINE_MOMENT`
a|image::{diagrams_uri}/event_timeline_moment.svg[id=event_timeline_moment]
|Event generated by system clock reaching a fixed time-point on the Work Plan timeline, specified by an offset from the Work Plan '0-point' plus an optional fixed time in the day. The latter enables fixed points in time such as a particular hour of day or customary time such as 'afternoon' to be specified. A combination of the two such as `P2D`, `13:30:00` can thus be used to state a time like '13:30 on day 2 of the plan'.

|`CALENDAR_EVENT`
a|image::{diagrams_uri}/event_calendar_event.svg[id=event_calendar_event]
|Event generated by system clock reaching an event in the global Plan calendar, which is specified in absolute time, independent of the Work Plan timeline.

|`TASK_TRANSITION`
a|image::{diagrams_uri}/event_task_transition.svg[id=event_task_transition]
|Event generated by the lifecycle transition of a Task, such as transition to `cancelled` or `done`.

|`STATE_TRIGGER`
a|image::{diagrams_uri}/event_state_trigger.svg[id=event_state_trigger]
|An event generated by a change in a tracked variable, or a Boolean expression based on tracked variables, e.g. a value reaching a threshold.

|`MANUAL_NOTIFICATION`
a|image::{diagrams_uri}/event_manual_notification.svg[id=event_manual_notification]
|An event that is manually notified to the Plan execution engine by a user.

|`SYSTEM_NOTIFICATION`
a|image::{diagrams_uri}/event_system_notification.svg[id=event_system_notification]
|An event that is notified to the Plan execution engine by a system.

|`DELAY_EVENT`
a|image::{diagrams_uri}/event_delay.svg[id=event_delay]
|A special kind of event is used to represent any other event with an added delay.

|`CALLBACK_NOTIFICATION`
a|image::{diagrams_uri}/event_callback.svg[id=event_callback]
|A callback notification connected to a dispatch for a Dispatchable Task (Hand-off, External Request, System Request).

|===

Instances of all of these types on their own only identify the type and source of an event - a wait state is required to catch an event. There are three types of wait state used in a TP definition: Task Wait, Timer Wait and Callback Wait. These are described below.

=== General Facilities

==== Timers

A generic timer can be specified using the Event type `TIMER_EVENT`. This is either attached to a `TASK_WAIT` wait state, which controls when a Task becomes available, or to a `TIMER_WAIT` wait state, which is used to represent a timeout on another wait state. `TIMER_WAIT` is based on the generic type `EVENT_WAIT<TIMER_EVENT>` and provides a way to specify a Timer (the `TIMER_EVENT` instance) and listen for it (the `TIMER_WAIT` instance).  A `TIMER_WAIT` creates a separate Event wait state that listens for a Timer event launched some duration after activation, and may result in specific actions, specified via the inherited `EVENT_WAIT._success_action_` attribute.

The timer represented by a `TIMER_EVENT` is started when the wait state to which it is attached is reached in the execution.

==== Event Wait State

The class `EVENT_WAIT<T>` defines a generic model of a general-purpose event wait state that may be specialised for particular purposes. Its attributes are as follows:

* `_success_action_` of type `EVENT_ACTION`, which defines possible actions to occur on receipt of an event;
* `_timeout_` of type `TIMER_WAIT`, whose `_success_action_` defines possible actions when no event is received.

The `EVENT_ACTION` type defines a number of things the system can do on a triggering event:

* make a system call, if the `_system_call_` attribute is set, e.g. to cause a notification to be sent or write to a system logger;
* displaying a message to the user, specified in the `_message_` attribute;
* optionally indicate a specific lifecycle state for the Plan Item (a Task or Task Group) receiving the event, specified by `_receiver_thread_next_state_`;
* optionally indicate where execution should resume in the plan, for example at an earlier Task, via the `_resume_action_` attribute, whose value is an instance of `RESUME_ACTION`, defining the `_resume_type_` and `_resume_location_` attributes.
    
=== Task Wait State

The principal way to wait for events is via the `TASK_WAIT` attachable to any `PLAN_ITEM` via the `_wait_spec_` attribute. The `TASK_WAIT` class represents a wait state that defines when a Task should enter the `available` state from the `planned` state in terms of Events of the types described above. Its `_events_` attribute enables multiple Events to be used as triggers, with an assumed logical OR relation among them. This enables the specification of triggers such as 'at 8pm on day 1, OR when oxygen saturation drops below 90% (whichever comes first)'. The optional `_event_relation_` attribute allows the Task to be specified as commencing `before`, `with` or `after` the trigger event (such as a meal). 

The following figure illustrates typical uses of `TASK_WAIT`.

[.text-center]
.Task wait state 
image::{diagrams_uri}/task_wait_state.svg[id=task_wait_state, align="center"]

==== Time-out

A timeout can be set on a Task Wait state by setting `TASK_WAIT._timeout_` with a `TIMER_WAIT` instance, which is activated when the Task Wait state is reached in the execution. This is useful in cases where Event receipt is not certain. The `TIMER_WAIT` generates a timer event if no other event is received; conversely, receipt of any other event cancels the timeout timer. The `TIMER_EVENT` attached to `TIMER_WAIT._event_` indicates the duration of the timer. The `_success_action_` of the `TIMER_WAIT` indicates actions to execute if the timer fires. The following Plan fragment illustrates.

[.text-center]
.Timing patterns
image::{diagrams_uri}/uc_task_timing_1.svg[id=timing_patterns_1, align="center"]

A Timeout can be also be used on a callback, via `CALLBACK_WAIT._timeout_`.

==== Reminder

When an event specified by a Task Wait state fires, it puts the Task into the `available` lifecycle state. In typical real world situations, the performer may not realise, or may be busy on something else. To enable the performer to be notified, and / or to indicate what delay before commencement is regarded as acceptable, the `TASK_WAIT._start_window_` attribute may be used to specify a `REMINDER` notification, which specifies a duration from the moment of first becoming available, optionally with a notification, specified via the inherited `_success_action_` attribute. If `REMINDER._repeats_` is non-zero, more than one reminder event may be generated. An example is illustrated below.

[.text-center]
.Task wait state with reminder
image::{diagrams_uri}/task_wait_state_reminder.svg[id=task_wait_state_reminder, align="center"]

The execution processing associated with a Reminder is that one or more Reminder events is generated by the system for a Task which is already `available`. Each of Reminder event will normally cause a communication to the principle performer via the message defined in its `_success_action_`. The performer responds by performing the work of the Task, and progressing it to a final state, in the normal way (possibly via the `underway` state, for a long-running Task). As soon as the Task is progressed beyond the `available` state, no further Reminders occur.

[.tbd]
TBD: need to define Plan level timeout behaviour, for case when no activity.

==== Lifecycle Transition Override

In some cases, it may be necessary to progress a Task to a state other than `available`. This may be achieved by specifying `TASK_WAIT._next_state_`.

=== Callbacks

A callback is the mechanism to state what happens when control returns to a Dispatchable Task (such as a Hand-off or External Request) from its target. It is defined in the model by `CALLBACK_WAIT`, a specialisation of `EVENT_WAIT<CALLBACK_NOTIFICATION>`, which represents a wait state to receive notifications of Dispatch completion, as well as timeout if no response is received. The callback event is formally represented by the `CALLBACK_NOTIFICATION` class. These classes are shown in the following view of the UML model.

[.text-center]
.Callback Wait
image::{uml_diagrams_uri}/PROC-task_planning.definition-callback_wait.svg[id=proc_definition_callback_wait, align="center"]

In order to define the processing on receipt of a callback event, `CALLBACK_WAIT` adds two attributes to `EVENT_WAIT<T>`:

* `_fail_action_`: enables a different `EVENT_ACTION` to be specified on receipt of a callback with a 'fail' status;
* `_custom_actions_`: enables a custom set of `EVENT_ACTIONs` to be specified, in the form of a Hash table, with a specific Event Action for each key; the keys are assumed to represent specific return statuses of the remote Task.

A Callback Wait thus has three standard Event responders: `_success_action_`, `_fail_action_` and `_timeout_`, and additionally any number of custom responders definable via `_custom_actions_`, described later.

A callback at execution time is achieved either internally in the TP system, or externally in the real world (e.g. by the subject returning to a clinic reception), which requires it to be manually signalled to the TP engine. The notification route is indicated by the attribute `CALLBACK_NOTIFICATION._manually_notified_`. In both cases, the `CALLBACK_NOTIFICATION` event carries the details of the event to be matched. In the manual notification, matching of `_subject_id_` etc will be carried out manually, e.g. by staff identifying the patient.

Task lifecycle state processing for a Dispatchable Task occurs both at the point of dispatch and return and/or timeout. The general model is as follows:

* the Task starts in the `planned` state, as for any Task in a Plan;
* when the execution point reaches the Task, and any Task Wait state has been exited, the Task becomes `available` (refer above to <<_task_availability>>);
* the Task dispatch operation is performed either automatically, or in the case of an External Request, manually;
* if `DISPATCHABLE_TASK._wait_` is `False`:
** the Task transitions to the `completed` state.
* if `DISPATCHABLE_TASK._wait_` is `True`:
** the Task enters the `underway` state until a callback (or timeout) occurs, at which point the next state will depend on the details of the callback (see below);

==== Callback Processing for Blocking Tasks

For a `DISPATCHABLE_TASK` that blocks and waits in the `underway` state, there are three callback processing models:

* `standard`: generic success | fail | timeout model;
* `order tracking`: used if `DISPATCHABLE_TASK._order_tags_` is set;
* `custom`: used if `DISPATCHABLE_TASK._callback.custom_actions_` is set.

Each model corresponds to a different set of possible callback statuses returned by the TP engine with the callback notification to represent the state of the remote Task execution. In the `standard` model it is a generic success | fail | timeout approach. Under the `order tracking` model (<<_order_tracking>>, above), the return statuses are states from the {openehr_rm_ehr}#_the_standard_instruction_state_machine_ism[openEHR Instruction State Machine]. Under the `custom` model, they are specific to the context.

Under each model, the next lifecycle state of the Dispatchable Task is determined by the callback status in a specific way. For each possible status under each model, a specific callback handler may be set, defined in terms of the `CALLBACK` properties `_success_action_`, `_fail_action_`, `_timeout.success_action_`. Any of these (see class `EVENT_ACTION`) if set may override the default next state, and also may generate a system call and/or a message for the performer.

[.tbd]
TBD: It would be reasonable to design an implementation with a default message of the form `"Task $task_name[id=$task_id] completed with $state"`, and a global flag `_default_messages_on_` to obviate the need to always set basic messages in `EVENT_ACTION`.

In special cases, it may also cause execution to resume in another place (see <<_resume_semantics>>).

A common approach to timeout processing applies to all models. If no callback occurs, and `CALLBACK._timeout.success_action_` is set, its timer will be used to generate the timeout, and also to determine the next state, message etc. If it is not set, the Work Plan global timeout will be triggered to unblock the Task and transition it to the `abandoned` state.

[.tbd]
TBD: need to define Plan level timeout.

The following table describes the details of callback processing under the various models.

[cols="2,2,3,3,3", stripes=none, options="header"]
|===
|Callback +
 model       |Callback +
              statuses |Dispatchable Task +
                        settings            |Response processing    |Notes

.2+a|*Standard*
.2+|_success_ +
 \| _fail_ +
 \| _timeout_
|no callback handlers
a|
* _success_ -> `completed` +
* _fail_ -> `abandoned` +
* _timeout_ -> `abandoned`
|

|callback handlers (`_success_action_`, `_fail_action_`, `_timeout.success_action_`)
a|As specified in `EVENT_ACTION.` +
 `_receiver_thread_next_state_`, +
 or else as above.
|Use to e.g. convert _fail_ to `cancelled`.

.2+a|*Order +
 tracking*
.2+|Action ISM state +
 \| _timeout_
|no callback handlers (except optionally `_timeout.success_action_`)
a|
* `planned` -> `underway` +
* `cancelled` -> `cancelled` +
* `postponed` -> `suspended` +
* `scheduled` -> `underway` +
* `active` -> `underway` +
* `suspended` -> `suspended` +
* `aborted` -> `cancelled` +
* `completed` -> `completed` +
* _timeout_ -> `abandoned`
|May catch multiple callbacks via use of `underway` target state. +
 +
 Only target states reachable from `underway` can be used.

|callback handlers (`_custom_actions_`, `_timeout.success_action_`)
a|As specified in `_custom_actions[n]. +
 receiver_thread_next_state_`, +
 or else as above
|

a|*Custom*
|Custom statuses +
 \| _timeout_
|callback handlers (`_custom_actions_`, `_timeout.success_action_`)
a|
* `xxx` -> `underway` +
* `yyy` -> `cancelled` +
* `zzz` -> `suspended` +
* etc
* _timeout_ -> `abandoned`
|May catch multiple callbacks via use of `underway` target state. +
 +
 Only target states reachable from `underway` can be used.
 
|===

The following diagram shows the TP-VML definition for a dispatchable Task with a standard callback.

[.text-center]
.Standard callback example
image::{diagrams_uri}/uc_task_callback_1.svg[id=timing_callback_pattern_1, align="center"]

The following TP-VML definition illustrates a custom callback.

[.text-center]
.Custom callback example
image::{diagrams_uri}/uc_task_callback_2.svg[id=timing_callback_pattern_2, align="center"]

==== Callback Processing for Non-blocking Tasks

In the case of a context fork, the source Task has performed its work as soon as the dispatch has occurred, and its state is set to `done`. The next Task(s) become `available` in the normal way, and processing continues. At some later point in time, a status notification of timeout may be received from the remote Task. This will be processed similarly to the above, with the exception that the next state processing, _if explicit next states are set_, is  _with respect to the enclosing Task Group_, which may be the top-level Group of the Task Plan. This allows the possibility of the callback processing to cause the local execution pathway to stop with abandonment, or cancellation. The default next-state processing is 'no change', i.e. the current execution path doesn't care what happens to the remote thread. However, if `EVENT_ACTION._receiver_thread_next_state_` is set for an execution status of the remote Task, the execution of the Task Group containing the source Task may be ended (`cancel`) or the whole Plan abandoned (`abandon`). Such a transition might even be set on `success`, which provides a way to model 'first one wins' logic.

The following illustrates a non-blocking callback in TP-VML.

[.text-center]
.Non-blocking callback example
image::{diagrams_uri}/dispatchable_no_wait_callback.svg[id=dispatchable_no_wait_callback, align="center"]

==== Callback with Custom Resume Behaviour

The attribute `EVENT_ACTION._resume_action_` of type `RESUME_ACTION`, and its attribute `_resume_location_` enable custom post-callback behaviour to be stated. The default is to process the `EVENT_ACTION` (e.g. post a message, make a system call etc), and then to complete the current Task and progress to the next in the normal way. A custom resume action alows a different resumption location to be specified, as defined by the enumeration `RESUME_TYPE`. This kind of resumption is described below in the section on <<_resume_semantics>>.

=== Class Definitions

include::{uml_export_dir}/classes/task_wait.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/plan_event.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/delay_event.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/manual_notification.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/system_notification.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/callback_notification.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/state_trigger.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/timer_event.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/calendar_event.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/timeline_moment.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_transition.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/event_wait.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/timer_wait.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/reminder.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/callback_wait.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/event_action.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/resume_action.adoc[leveloffset=+1]

